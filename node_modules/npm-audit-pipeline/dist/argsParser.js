"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseCommandLineArgs = void 0;
var function_1 = require("fp-ts/lib/function");
var O = require("fp-ts/Option");
var E = require("fp-ts/Either");
var boolean_1 = require("fp-ts/boolean");
var String = require("fp-ts/string");
var t = require("io-ts");
var A = require("fp-ts/Array");
var RA = require("fp-ts/ReadonlyArray");
var Apply_1 = require("fp-ts/Apply");
var packageManagerTypes = t.union([
    t.literal('npm'),
    t.literal('yarn'),
    t.literal('pnpm'),
]);
var vulnerabilityFlagRegex = /^--(low|moderate|high|critical|retry)=[0-9]+$/;
var packageManagerFlagRegex = /^--package-manager=(npm|yarn|pnpm)$/;
var defaultConfig = {
    shouldWarn: false,
    retry: 3,
    info: 0,
    low: 0,
    moderate: 0,
    high: 0,
    critical: 0,
    packageManager: 'npm',
};
var isArgsValid = function (flagArg) {
    return new RegExp(/(^|\s)--[^\d\W]+/).test(flagArg);
};
var isVulnerabilityFlag = function (flagArg) {
    return new RegExp(vulnerabilityFlagRegex).test(flagArg);
};
var isPackageManagerFlagRegex = function (flagArg) {
    return new RegExp(packageManagerFlagRegex).test(flagArg);
};
var parseVulnerabilityFlagArg = function (flagArg) {
    return (0, function_1.pipe)(O.fromNullable(new RegExp(vulnerabilityFlagRegex).exec(flagArg)), O.chain(A.head), O.map(function (x) { return x.split('='); }), O.chain(function (x) {
        return (0, Apply_1.sequenceS)(O.option)({
            key: (0, function_1.pipe)(A.lookup(0)(x), O.map(function (x) { return x.replace('--', ''); })),
            count: (0, function_1.pipe)(A.lookup(1)(x), O.map(parseInt)),
        });
    }), E.fromOption(function () { return new Error('Failed to parse command line arguments'); }));
};
var parseVulnerabilityFlagArgs = function (args) {
    return (0, function_1.pipe)(args.filter(isVulnerabilityFlag), A.map(parseVulnerabilityFlagArg), E.sequenceArray, E.map(function (x) {
        return x.reduce(function (prev, curr) {
            var _a;
            return (__assign(__assign({}, prev), (_a = {}, _a[curr.key] = curr.count, _a)));
        }, defaultConfig);
    }));
};
var parsePackageManagerFlag = function (args) {
    return function (config) {
        return (0, function_1.pipe)(args.filter(isPackageManagerFlagRegex), A.head, O.fold(function () { return E.right(config); }, (0, function_1.flow)(String.split('='), RA.lookup(1), E.fromOption(function () { return new Error('Failed to parse command line arguments'); }), E.chain((0, function_1.flow)(packageManagerTypes.decode, E.mapLeft(function () { return new Error('Failed to parse command line arguments'); }))), E.map(function (x) { return (__assign(__assign({}, config), { packageManager: x })); }))));
    };
};
var parseOtherFlagArgs = function (args) { return function (config) { return (__assign(__assign({}, config), { shouldWarn: args.some(function (x) { return x === '--warn'; }) })); }; };
var parseCommandLineArgs = function (args) {
    return (0, function_1.pipe)(args.every(isArgsValid), (0, boolean_1.match)(function () { return E.left(new Error('one of the arguments is invalid')); }, function () {
        return (0, function_1.pipe)(args, parseVulnerabilityFlagArgs, E.chain(parsePackageManagerFlag(args)), E.map(parseOtherFlagArgs(args)));
    }));
};
exports.parseCommandLineArgs = parseCommandLineArgs;
